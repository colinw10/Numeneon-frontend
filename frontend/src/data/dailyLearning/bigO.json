[
  {
    "id": 1,
    "term": "O(1) - Constant Time",
    "term_es": "O(1) - Tiempo Constante",
    "pronunciation": "oh-one",
    "definition": "Operations that take the same time regardless of input size",
    "definition_es": "Operaciones que toman el mismo tiempo sin importar el tamaño de entrada",
    "example": "Accessing an array element by index: arr[5]",
    "example_es": "Acceder a un elemento de array por índice: arr[5]",
    "code": "// O(1) - Always one operation\nfunction getFirst(arr) {\n  return arr[0];\n}",
    "realWorld": "Looking up a word in a dictionary by page number",
    "realWorld_es": "Buscar una palabra en un diccionario por número de página"
  },
  {
    "id": 2,
    "term": "O(log n) - Logarithmic Time",
    "term_es": "O(log n) - Tiempo Logarítmico",
    "pronunciation": "oh-log-n",
    "definition": "Operations that halve the problem size with each step",
    "definition_es": "Operaciones que reducen a la mitad el problema con cada paso",
    "example": "Binary search in a sorted array",
    "example_es": "Búsqueda binaria en un array ordenado",
    "code": "// O(log n) - Halves search space each iteration\nfunction binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n}",
    "realWorld": "Finding a name in a phone book by repeatedly opening to the middle",
    "realWorld_es": "Encontrar un nombre en una guía telefónica abriendo repetidamente por la mitad"
  },
  {
    "id": 3,
    "term": "O(n) - Linear Time",
    "term_es": "O(n) - Tiempo Lineal",
    "pronunciation": "oh-n",
    "definition": "Operations that scale directly with input size",
    "definition_es": "Operaciones que escalan directamente con el tamaño de entrada",
    "example": "Finding the max value in an unsorted array",
    "example_es": "Encontrar el valor máximo en un array desordenado",
    "code": "// O(n) - Must check every element\nfunction findMax(arr) {\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) max = arr[i];\n  }\n  return max;\n}",
    "realWorld": "Reading every page of a book to find a specific quote",
    "realWorld_es": "Leer cada página de un libro para encontrar una cita específica"
  },
  {
    "id": 4,
    "term": "O(n log n) - Linearithmic Time",
    "term_es": "O(n log n) - Tiempo Linealítmico",
    "pronunciation": "oh-n-log-n",
    "definition": "Efficient sorting algorithms; combines linear iteration with logarithmic division",
    "definition_es": "Algoritmos de ordenamiento eficientes; combina iteración lineal con división logarítmica",
    "example": "Merge sort, quicksort (average case), heapsort",
    "example_es": "Merge sort, quicksort (caso promedio), heapsort",
    "code": "// O(n log n) - Divide and conquer\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  return merge(left, right);\n}",
    "realWorld": "Organizing a deck of cards by repeatedly splitting and merging piles",
    "realWorld_es": "Organizar una baraja dividiendo y fusionando pilas repetidamente"
  },
  {
    "id": 5,
    "term": "O(n²) - Quadratic Time",
    "term_es": "O(n²) - Tiempo Cuadrático",
    "pronunciation": "oh-n-squared",
    "definition": "Operations with nested iteration over the input",
    "definition_es": "Operaciones con iteración anidada sobre la entrada",
    "example": "Bubble sort, comparing every pair of elements",
    "example_es": "Bubble sort, comparando cada par de elementos",
    "code": "// O(n²) - Nested loops\nfunction bubbleSort(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n      }\n    }\n  }\n  return arr;\n}",
    "realWorld": "Comparing every student's test score with every other student's",
    "realWorld_es": "Comparar la calificación de cada estudiante con la de todos los demás"
  },
  {
    "id": 6,
    "term": "O(2ⁿ) - Exponential Time",
    "term_es": "O(2ⁿ) - Tiempo Exponencial",
    "pronunciation": "oh-two-to-the-n",
    "definition": "Operations that double with each additional input element",
    "definition_es": "Operaciones que se duplican con cada elemento adicional de entrada",
    "example": "Recursive Fibonacci without memoization",
    "example_es": "Fibonacci recursivo sin memoización",
    "code": "// O(2ⁿ) - Doubles each level\nfunction fib(n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n// fib(40) = 1+ billion operations!",
    "realWorld": "Trying every possible combination of on/off switches",
    "realWorld_es": "Probar cada combinación posible de interruptores encendido/apagado"
  },
  {
    "id": 7,
    "term": "O(n!) - Factorial Time",
    "term_es": "O(n!) - Tiempo Factorial",
    "pronunciation": "oh-n-factorial",
    "definition": "Operations that consider every possible permutation",
    "definition_es": "Operaciones que consideran cada permutación posible",
    "example": "Brute-force solving the traveling salesman problem",
    "example_es": "Resolver por fuerza bruta el problema del viajante",
    "code": "// O(n!) - All permutations\nfunction permutations(arr) {\n  if (arr.length <= 1) return [arr];\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];\n    for (const perm of permutations(rest)) {\n      result.push([arr[i], ...perm]);\n    }\n  }\n  return result;\n}",
    "realWorld": "Finding the best order to visit 10 cities = 3,628,800 routes to check",
    "realWorld_es": "Encontrar el mejor orden para visitar 10 ciudades = 3,628,800 rutas a verificar"
  },
  {
    "id": 8,
    "term": "Amortized O(1)",
    "term_es": "O(1) Amortizado",
    "pronunciation": "AM-or-tized oh-one",
    "definition": "Operations that are occasionally expensive but average to constant time over many calls",
    "definition_es": "Operaciones que ocasionalmente son costosas pero promedian tiempo constante en muchas llamadas",
    "example": "Array push() - usually O(1), but O(n) when resizing",
    "example_es": "Array push() - usualmente O(1), pero O(n) al redimensionar",
    "code": "// Amortized O(1)\n// Array doubles capacity when full\narr.push(item); // Usually instant\n// Occasionally copies entire array\n// But averages out to O(1) per operation",
    "realWorld": "Filling a glass that magically doubles in size when full",
    "realWorld_es": "Llenar un vaso que mágicamente duplica su tamaño cuando está lleno"
  },
  {
    "id": 9,
    "term": "Space Complexity",
    "term_es": "Complejidad Espacial",
    "pronunciation": "spays kom-PLEK-sih-tee",
    "definition": "The amount of memory an algorithm uses relative to input size",
    "definition_es": "La cantidad de memoria que un algoritmo usa relativa al tamaño de entrada",
    "example": "Merge sort uses O(n) extra space; quicksort uses O(log n)",
    "example_es": "Merge sort usa O(n) espacio extra; quicksort usa O(log n)",
    "code": "// O(1) space - in-place\nfunction reverse(arr) {\n  let l = 0, r = arr.length - 1;\n  while (l < r) {\n    [arr[l], arr[r]] = [arr[r], arr[l]];\n    l++; r--;\n  }\n}\n\n// O(n) space - creates new array\nfunction reverseCopy(arr) {\n  return [...arr].reverse();\n}",
    "realWorld": "Doing math in your head (O(1)) vs writing it out on paper (O(n))",
    "realWorld_es": "Hacer matemáticas mentalmente (O(1)) vs escribirlo en papel (O(n))"
  },
  {
    "id": 10,
    "term": "Best/Worst/Average Case",
    "term_es": "Caso Mejor/Peor/Promedio",
    "pronunciation": "kayss",
    "definition": "Different scenarios for algorithm performance based on input characteristics",
    "definition_es": "Diferentes escenarios de rendimiento del algoritmo según características de entrada",
    "example": "Quicksort: Best O(n log n), Average O(n log n), Worst O(n²)",
    "example_es": "Quicksort: Mejor O(n log n), Promedio O(n log n), Peor O(n²)",
    "code": "// Quicksort worst case: already sorted\n[1, 2, 3, 4, 5] // O(n²) - bad pivot choices\n\n// Quicksort best case: random order\n[3, 1, 4, 5, 2] // O(n log n) - good pivots",
    "realWorld": "Finding your keys: best case (in pocket), worst case (check everywhere)",
    "realWorld_es": "Encontrar tus llaves: mejor caso (en el bolsillo), peor caso (buscar por todas partes)"
  },
  {
    "id": 11,
    "term": "Hash Table O(1)",
    "term_es": "Tabla Hash O(1)",
    "pronunciation": "hash-TAY-bul",
    "definition": "Data structure providing constant-time lookup, insert, and delete on average",
    "definition_es": "Estructura de datos que proporciona búsqueda, inserción y eliminación en tiempo constante promedio",
    "example": "JavaScript objects and Maps use hash tables internally",
    "example_es": "Objetos JavaScript y Maps usan tablas hash internamente",
    "code": "// O(1) average lookup\nconst map = new Map();\nmap.set('user:123', userData); // O(1)\nmap.get('user:123');           // O(1)\nmap.has('user:123');           // O(1)\nmap.delete('user:123');        // O(1)",
    "realWorld": "Finding a book using its library call number instead of searching every shelf",
    "realWorld_es": "Encontrar un libro usando su código de biblioteca en vez de buscar en cada estante"
  },
  {
    "id": 12,
    "term": "O(n + m)",
    "pronunciation": "oh-n-plus-m",
    "definition": "Operations that process two inputs independently",
    "definition_es": "Operaciones que procesan dos entradas independientemente",
    "example": "Merging two sorted arrays of different sizes",
    "example_es": "Fusionar dos arrays ordenados de diferentes tamaños",
    "code": "// O(n + m) - process both arrays once\nfunction merge(arr1, arr2) {\n  const result = [];\n  let i = 0, j = 0;\n  while (i < arr1.length && j < arr2.length) {\n    if (arr1[i] < arr2[j]) result.push(arr1[i++]);\n    else result.push(arr2[j++]);\n  }\n  return [...result, ...arr1.slice(i), ...arr2.slice(j)];\n}",
    "realWorld": "Reading two different books - time depends on both lengths",
    "realWorld_es": "Leer dos libros diferentes - el tiempo depende de la longitud de ambos"
  },
  {
    "id": 13,
    "term": "O(n * m)",
    "pronunciation": "oh-n-times-m",
    "definition": "Operations that iterate through combinations of two inputs",
    "definition_es": "Operaciones que iteran a través de combinaciones de dos entradas",
    "example": "Comparing every element of array1 with every element of array2",
    "example_es": "Comparar cada elemento de array1 con cada elemento de array2",
    "code": "// O(n * m) - nested loops over different arrays\nfunction findCommon(arr1, arr2) {\n  const common = [];\n  for (const a of arr1) {      // n iterations\n    for (const b of arr2) {    // m iterations each\n      if (a === b) common.push(a);\n    }\n  }\n  return common;\n}",
    "realWorld": "Comparing every student in class A with every student in class B",
    "realWorld_es": "Comparar cada estudiante de la clase A con cada estudiante de la clase B"
  },
  {
    "id": 14,
    "term": "O(√n) - Square Root Time",
    "term_es": "O(√n) - Tiempo Raíz Cuadrada",
    "pronunciation": "oh-root-n",
    "definition": "Operations that check up to the square root of the input",
    "definition_es": "Operaciones que verifican hasta la raíz cuadrada de la entrada",
    "example": "Checking if a number is prime",
    "example_es": "Verificar si un número es primo",
    "code": "// O(√n) - only check up to square root\nfunction isPrime(n) {\n  if (n < 2) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n}\n// For n=100, only check 2-10, not 2-99",
    "realWorld": "If 100 has a factor > 10, it must also have one < 10",
    "realWorld_es": "Si 100 tiene un factor > 10, debe tener también uno < 10"
  },
  {
    "id": 15,
    "term": "Tail Recursion",
    "term_es": "Recursión de Cola",
    "pronunciation": "tayl ree-KUR-zhun",
    "definition": "Recursion where the recursive call is the last operation, enabling O(1) space optimization",
    "definition_es": "Recursión donde la llamada recursiva es la última operación, permitiendo optimización O(1) de espacio",
    "example": "Some languages optimize tail calls to avoid stack overflow",
    "example_es": "Algunos lenguajes optimizan llamadas de cola para evitar desbordamiento de pila",
    "code": "// NOT tail recursive - must remember to add n\nfunction factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\n\n// Tail recursive - result passed along\nfunction factorialTail(n, acc = 1) {\n  if (n <= 1) return acc;\n  return factorialTail(n - 1, n * acc);\n}",
    "realWorld": "Passing a running total forward vs remembering to add later",
    "realWorld_es": "Pasar un total acumulado hacia adelante vs recordar sumar después"
  }
]
