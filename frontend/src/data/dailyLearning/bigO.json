[
  {
    "id": 1,
    "term": "O(1) - Constant Time",
    "pronunciation": "oh-one",
    "definition": "Operations that take the same time regardless of input size",
    "example": "Accessing an array element by index: arr[5]",
    "code": "// O(1) - Always one operation\nfunction getFirst(arr) {\n  return arr[0];\n}",
    "realWorld": "Looking up a word in a dictionary by page number"
  },
  {
    "id": 2,
    "term": "O(log n) - Logarithmic Time",
    "pronunciation": "oh-log-n",
    "definition": "Operations that halve the problem size with each step",
    "example": "Binary search in a sorted array",
    "code": "// O(log n) - Halves search space each iteration\nfunction binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n}",
    "realWorld": "Finding a name in a phone book by repeatedly opening to the middle"
  },
  {
    "id": 3,
    "term": "O(n) - Linear Time",
    "pronunciation": "oh-n",
    "definition": "Operations that scale directly with input size",
    "example": "Finding the max value in an unsorted array",
    "code": "// O(n) - Must check every element\nfunction findMax(arr) {\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) max = arr[i];\n  }\n  return max;\n}",
    "realWorld": "Reading every page of a book to find a specific quote"
  },
  {
    "id": 4,
    "term": "O(n log n) - Linearithmic Time",
    "pronunciation": "oh-n-log-n",
    "definition": "Efficient sorting algorithms; combines linear iteration with logarithmic division",
    "example": "Merge sort, quicksort (average case), heapsort",
    "code": "// O(n log n) - Divide and conquer\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  return merge(left, right);\n}",
    "realWorld": "Organizing a deck of cards by repeatedly splitting and merging piles"
  },
  {
    "id": 5,
    "term": "O(n²) - Quadratic Time",
    "pronunciation": "oh-n-squared",
    "definition": "Operations with nested iteration over the input",
    "example": "Bubble sort, comparing every pair of elements",
    "code": "// O(n²) - Nested loops\nfunction bubbleSort(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n      }\n    }\n  }\n  return arr;\n}",
    "realWorld": "Comparing every student's test score with every other student's"
  },
  {
    "id": 6,
    "term": "O(2ⁿ) - Exponential Time",
    "pronunciation": "oh-two-to-the-n",
    "definition": "Operations that double with each additional input element",
    "example": "Recursive Fibonacci without memoization",
    "code": "// O(2ⁿ) - Doubles each level\nfunction fib(n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n// fib(40) = 1+ billion operations!",
    "realWorld": "Trying every possible combination of on/off switches"
  },
  {
    "id": 7,
    "term": "O(n!) - Factorial Time",
    "pronunciation": "oh-n-factorial",
    "definition": "Operations that consider every possible permutation",
    "example": "Brute-force solving the traveling salesman problem",
    "code": "// O(n!) - All permutations\nfunction permutations(arr) {\n  if (arr.length <= 1) return [arr];\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];\n    for (const perm of permutations(rest)) {\n      result.push([arr[i], ...perm]);\n    }\n  }\n  return result;\n}",
    "realWorld": "Finding the best order to visit 10 cities = 3,628,800 routes to check"
  },
  {
    "id": 8,
    "term": "Amortized O(1)",
    "pronunciation": "AM-or-tized oh-one",
    "definition": "Operations that are occasionally expensive but average to constant time over many calls",
    "example": "Array push() - usually O(1), but O(n) when resizing",
    "code": "// Amortized O(1)\n// Array doubles capacity when full\narr.push(item); // Usually instant\n// Occasionally copies entire array\n// But averages out to O(1) per operation",
    "realWorld": "Filling a glass that magically doubles in size when full"
  },
  {
    "id": 9,
    "term": "Space Complexity",
    "pronunciation": "spays kom-PLEK-sih-tee",
    "definition": "The amount of memory an algorithm uses relative to input size",
    "example": "Merge sort uses O(n) extra space; quicksort uses O(log n)",
    "code": "// O(1) space - in-place\nfunction reverse(arr) {\n  let l = 0, r = arr.length - 1;\n  while (l < r) {\n    [arr[l], arr[r]] = [arr[r], arr[l]];\n    l++; r--;\n  }\n}\n\n// O(n) space - creates new array\nfunction reverseCopy(arr) {\n  return [...arr].reverse();\n}",
    "realWorld": "Doing math in your head (O(1)) vs writing it out on paper (O(n))"
  },
  {
    "id": 10,
    "term": "Best/Worst/Average Case",
    "pronunciation": "kayss",
    "definition": "Different scenarios for algorithm performance based on input characteristics",
    "example": "Quicksort: Best O(n log n), Average O(n log n), Worst O(n²)",
    "code": "// Quicksort worst case: already sorted\n[1, 2, 3, 4, 5] // O(n²) - bad pivot choices\n\n// Quicksort best case: random order\n[3, 1, 4, 5, 2] // O(n log n) - good pivots",
    "realWorld": "Finding your keys: best case (in pocket), worst case (check everywhere)"
  },
  {
    "id": 11,
    "term": "Hash Table O(1)",
    "pronunciation": "hash-TAY-bul",
    "definition": "Data structure providing constant-time lookup, insert, and delete on average",
    "example": "JavaScript objects and Maps use hash tables internally",
    "code": "// O(1) average lookup\nconst map = new Map();\nmap.set('user:123', userData); // O(1)\nmap.get('user:123');           // O(1)\nmap.has('user:123');           // O(1)\nmap.delete('user:123');        // O(1)",
    "realWorld": "Finding a book using its library call number instead of searching every shelf"
  },
  {
    "id": 12,
    "term": "O(n + m)",
    "pronunciation": "oh-n-plus-m",
    "definition": "Operations that process two inputs independently",
    "example": "Merging two sorted arrays of different sizes",
    "code": "// O(n + m) - process both arrays once\nfunction merge(arr1, arr2) {\n  const result = [];\n  let i = 0, j = 0;\n  while (i < arr1.length && j < arr2.length) {\n    if (arr1[i] < arr2[j]) result.push(arr1[i++]);\n    else result.push(arr2[j++]);\n  }\n  return [...result, ...arr1.slice(i), ...arr2.slice(j)];\n}",
    "realWorld": "Reading two different books - time depends on both lengths"
  },
  {
    "id": 13,
    "term": "O(n * m)",
    "pronunciation": "oh-n-times-m",
    "definition": "Operations that iterate through combinations of two inputs",
    "example": "Comparing every element of array1 with every element of array2",
    "code": "// O(n * m) - nested loops over different arrays\nfunction findCommon(arr1, arr2) {\n  const common = [];\n  for (const a of arr1) {      // n iterations\n    for (const b of arr2) {    // m iterations each\n      if (a === b) common.push(a);\n    }\n  }\n  return common;\n}",
    "realWorld": "Comparing every student in class A with every student in class B"
  },
  {
    "id": 14,
    "term": "O(√n) - Square Root Time",
    "pronunciation": "oh-root-n",
    "definition": "Operations that check up to the square root of the input",
    "example": "Checking if a number is prime",
    "code": "// O(√n) - only check up to square root\nfunction isPrime(n) {\n  if (n < 2) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n}\n// For n=100, only check 2-10, not 2-99",
    "realWorld": "If 100 has a factor > 10, it must also have one < 10"
  },
  {
    "id": 15,
    "term": "Tail Recursion",
    "pronunciation": "tayl ree-KUR-zhun",
    "definition": "Recursion where the recursive call is the last operation, enabling O(1) space optimization",
    "example": "Some languages optimize tail calls to avoid stack overflow",
    "code": "// NOT tail recursive - must remember to add n\nfunction factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\n\n// Tail recursive - result passed along\nfunction factorialTail(n, acc = 1) {\n  if (n <= 1) return acc;\n  return factorialTail(n - 1, n * acc);\n}",
    "realWorld": "Passing a running total forward vs remembering to add later"
  }
]
